{"ast":null,"code":"'use strict';\n\nvar Dimensions = require(\"../Utilities/Dimensions\");\n\nvar FrameRateLogger = require(\"../Interaction/FrameRateLogger\");\n\nvar Keyboard = require(\"./Keyboard/Keyboard\");\n\nvar Platform = require(\"../Utilities/Platform\");\n\nvar React = require('react');\n\nvar ReactNative = require(\"../Renderer/shims/ReactNative\");\n\nvar TextInputState = require(\"./TextInput/TextInputState\");\n\nvar UIManager = require(\"../ReactNative/UIManager\");\n\nvar invariant = require('invariant');\n\nimport Commands from \"./ScrollView/ScrollViewCommands\";\nvar IS_ANIMATING_TOUCH_START_THRESHOLD_MS = 16;\nvar ScrollResponderMixin = {\n  _subscriptionKeyboardWillShow: null,\n  _subscriptionKeyboardWillHide: null,\n  _subscriptionKeyboardDidShow: null,\n  _subscriptionKeyboardDidHide: null,\n  scrollResponderMixinGetInitialState: function scrollResponderMixinGetInitialState() {\n    return {\n      isTouching: false,\n      lastMomentumScrollBeginTime: 0,\n      lastMomentumScrollEndTime: 0,\n      observedScrollSinceBecomingResponder: false,\n      becameResponderWhileAnimating: false\n    };\n  },\n  scrollResponderHandleScrollShouldSetResponder: function scrollResponderHandleScrollShouldSetResponder() {\n    if (this.props.disableScrollViewPanResponder === true) {\n      return false;\n    }\n\n    return this.state.isTouching;\n  },\n  scrollResponderHandleStartShouldSetResponder: function scrollResponderHandleStartShouldSetResponder(e) {\n    if (this.props.disableScrollViewPanResponder === true) {\n      return false;\n    }\n\n    var currentlyFocusedInput = TextInputState.currentlyFocusedInput();\n\n    if (this.props.keyboardShouldPersistTaps === 'handled' && this.scrollResponderKeyboardIsDismissible() && e.target !== currentlyFocusedInput) {\n      return true;\n    }\n\n    return false;\n  },\n  scrollResponderHandleStartShouldSetResponderCapture: function scrollResponderHandleStartShouldSetResponderCapture(e) {\n    if (this.scrollResponderIsAnimating()) {\n      return true;\n    }\n\n    if (this.props.disableScrollViewPanResponder === true) {\n      return false;\n    }\n\n    var keyboardShouldPersistTaps = this.props.keyboardShouldPersistTaps;\n    var keyboardNeverPersistTaps = !keyboardShouldPersistTaps || keyboardShouldPersistTaps === 'never';\n\n    if (typeof e.target === 'number') {\n      if (__DEV__) {\n        console.error('Did not expect event target to be a number. Should have been a native component');\n      }\n\n      return false;\n    }\n\n    if (keyboardNeverPersistTaps && this.scrollResponderKeyboardIsDismissible() && e.target != null && !TextInputState.isTextInput(e.target)) {\n      return true;\n    }\n\n    return false;\n  },\n  scrollResponderKeyboardIsDismissible: function scrollResponderKeyboardIsDismissible() {\n    var currentlyFocusedInput = TextInputState.currentlyFocusedInput();\n    var hasFocusedTextInput = currentlyFocusedInput != null && TextInputState.isTextInput(currentlyFocusedInput);\n    var softKeyboardMayBeOpen = this.keyboardWillOpenTo != null || Platform.OS === 'android';\n    return hasFocusedTextInput && softKeyboardMayBeOpen;\n  },\n  scrollResponderHandleResponderReject: function scrollResponderHandleResponderReject() {},\n  scrollResponderHandleTerminationRequest: function scrollResponderHandleTerminationRequest() {\n    return !this.state.observedScrollSinceBecomingResponder;\n  },\n  scrollResponderHandleTouchEnd: function scrollResponderHandleTouchEnd(e) {\n    var nativeEvent = e.nativeEvent;\n    this.state.isTouching = nativeEvent.touches.length !== 0;\n    this.props.onTouchEnd && this.props.onTouchEnd(e);\n  },\n  scrollResponderHandleTouchCancel: function scrollResponderHandleTouchCancel(e) {\n    this.state.isTouching = false;\n    this.props.onTouchCancel && this.props.onTouchCancel(e);\n  },\n  scrollResponderHandleResponderRelease: function scrollResponderHandleResponderRelease(e) {\n    this.props.onResponderRelease && this.props.onResponderRelease(e);\n\n    if (typeof e.target === 'number') {\n      if (__DEV__) {\n        console.error('Did not expect event target to be a number. Should have been a native component');\n      }\n\n      return;\n    }\n\n    var currentlyFocusedTextInput = TextInputState.currentlyFocusedInput();\n\n    if (this.props.keyboardShouldPersistTaps !== true && this.props.keyboardShouldPersistTaps !== 'always' && this.scrollResponderKeyboardIsDismissible() && e.target !== currentlyFocusedTextInput && !this.state.observedScrollSinceBecomingResponder && !this.state.becameResponderWhileAnimating) {\n      this.props.onScrollResponderKeyboardDismissed && this.props.onScrollResponderKeyboardDismissed(e);\n      TextInputState.blurTextInput(currentlyFocusedTextInput);\n    }\n  },\n  scrollResponderHandleScroll: function scrollResponderHandleScroll(e) {\n    this.state.observedScrollSinceBecomingResponder = true;\n    this.props.onScroll && this.props.onScroll(e);\n  },\n  scrollResponderHandleResponderGrant: function scrollResponderHandleResponderGrant(e) {\n    this.state.observedScrollSinceBecomingResponder = false;\n    this.props.onResponderGrant && this.props.onResponderGrant(e);\n    this.state.becameResponderWhileAnimating = this.scrollResponderIsAnimating();\n  },\n  scrollResponderHandleScrollBeginDrag: function scrollResponderHandleScrollBeginDrag(e) {\n    FrameRateLogger.beginScroll();\n    this.props.onScrollBeginDrag && this.props.onScrollBeginDrag(e);\n  },\n  scrollResponderHandleScrollEndDrag: function scrollResponderHandleScrollEndDrag(e) {\n    var velocity = e.nativeEvent.velocity;\n\n    if (!this.scrollResponderIsAnimating() && (!velocity || velocity.x === 0 && velocity.y === 0)) {\n      FrameRateLogger.endScroll();\n    }\n\n    this.props.onScrollEndDrag && this.props.onScrollEndDrag(e);\n  },\n  scrollResponderHandleMomentumScrollBegin: function scrollResponderHandleMomentumScrollBegin(e) {\n    this.state.lastMomentumScrollBeginTime = global.performance.now();\n    this.props.onMomentumScrollBegin && this.props.onMomentumScrollBegin(e);\n  },\n  scrollResponderHandleMomentumScrollEnd: function scrollResponderHandleMomentumScrollEnd(e) {\n    FrameRateLogger.endScroll();\n    this.state.lastMomentumScrollEndTime = global.performance.now();\n    this.props.onMomentumScrollEnd && this.props.onMomentumScrollEnd(e);\n  },\n  scrollResponderHandleTouchStart: function scrollResponderHandleTouchStart(e) {\n    this.state.isTouching = true;\n    this.props.onTouchStart && this.props.onTouchStart(e);\n  },\n  scrollResponderHandleTouchMove: function scrollResponderHandleTouchMove(e) {\n    this.props.onTouchMove && this.props.onTouchMove(e);\n  },\n  scrollResponderIsAnimating: function scrollResponderIsAnimating() {\n    var now = global.performance.now();\n    var timeSinceLastMomentumScrollEnd = now - this.state.lastMomentumScrollEndTime;\n    var isAnimating = timeSinceLastMomentumScrollEnd < IS_ANIMATING_TOUCH_START_THRESHOLD_MS || this.state.lastMomentumScrollEndTime < this.state.lastMomentumScrollBeginTime;\n    return isAnimating;\n  },\n  scrollResponderGetScrollableNode: function scrollResponderGetScrollableNode() {\n    return this.getScrollableNode ? this.getScrollableNode() : ReactNative.findNodeHandle(this);\n  },\n  scrollResponderScrollTo: function scrollResponderScrollTo(x, y, animated) {\n    if (typeof x === 'number') {\n      console.warn('`scrollResponderScrollTo(x, y, animated)` is deprecated. Use `scrollResponderScrollTo({x: 5, y: 5, animated: true})` instead.');\n    } else {\n      var _ref = x || {};\n\n      x = _ref.x;\n      y = _ref.y;\n      animated = _ref.animated;\n    }\n\n    var that = this;\n    invariant(that.getNativeScrollRef != null, 'Expected scrollTo to be called on a scrollViewRef. If this exception occurs it is likely a bug in React Native');\n    var nativeScrollRef = that.getNativeScrollRef();\n\n    if (nativeScrollRef == null) {\n      return;\n    }\n\n    Commands.scrollTo(nativeScrollRef, x || 0, y || 0, animated !== false);\n  },\n  scrollResponderScrollToEnd: function scrollResponderScrollToEnd(options) {\n    var animated = (options && options.animated) !== false;\n    var that = this;\n    invariant(that.getNativeScrollRef != null, 'Expected scrollToEnd to be called on a scrollViewRef. If this exception occurs it is likely a bug in React Native');\n    var nativeScrollRef = that.getNativeScrollRef();\n\n    if (nativeScrollRef == null) {\n      return;\n    }\n\n    Commands.scrollToEnd(nativeScrollRef, animated);\n  },\n  scrollResponderZoomTo: function scrollResponderZoomTo(rect, animated) {\n    invariant(Platform.OS === 'ios', 'zoomToRect is not implemented');\n\n    if ('animated' in rect) {\n      animated = rect.animated;\n      delete rect.animated;\n    } else if (typeof animated !== 'undefined') {\n      console.warn('`scrollResponderZoomTo` `animated` argument is deprecated. Use `options.animated` instead');\n    }\n\n    var that = this;\n    invariant(that.getNativeScrollRef != null, 'Expected zoomToRect to be called on a scrollViewRef. If this exception occurs it is likely a bug in React Native');\n    var nativeScrollRef = that.getNativeScrollRef();\n\n    if (nativeScrollRef == null) {\n      return;\n    }\n\n    Commands.zoomToRect(nativeScrollRef, rect, animated !== false);\n  },\n  scrollResponderFlashScrollIndicators: function scrollResponderFlashScrollIndicators() {\n    var that = this;\n    invariant(that.getNativeScrollRef != null, 'Expected flashScrollIndicators to be called on a scrollViewRef. If this exception occurs it is likely a bug in React Native');\n    var nativeScrollRef = that.getNativeScrollRef();\n\n    if (nativeScrollRef == null) {\n      return;\n    }\n\n    Commands.flashScrollIndicators(nativeScrollRef);\n  },\n  scrollResponderScrollNativeHandleToKeyboard: function scrollResponderScrollNativeHandleToKeyboard(nodeHandle, additionalOffset, preventNegativeScrollOffset) {\n    this.additionalScrollOffset = additionalOffset || 0;\n    this.preventNegativeScrollOffset = !!preventNegativeScrollOffset;\n\n    if (typeof nodeHandle === 'number') {\n      UIManager.measureLayout(nodeHandle, ReactNative.findNodeHandle(this.getInnerViewNode()), this.scrollResponderTextInputFocusError, this.scrollResponderInputMeasureAndScrollToKeyboard);\n    } else {\n      var innerRef = this.getInnerViewRef();\n\n      if (innerRef == null) {\n        return;\n      }\n\n      nodeHandle.measureLayout(innerRef, this.scrollResponderInputMeasureAndScrollToKeyboard, this.scrollResponderTextInputFocusError);\n    }\n  },\n  scrollResponderInputMeasureAndScrollToKeyboard: function scrollResponderInputMeasureAndScrollToKeyboard(left, top, width, height) {\n    var keyboardScreenY = Dimensions.get('window').height;\n\n    if (this.keyboardWillOpenTo) {\n      keyboardScreenY = this.keyboardWillOpenTo.endCoordinates.screenY;\n    }\n\n    var scrollOffsetY = top - keyboardScreenY + height + this.additionalScrollOffset;\n\n    if (this.preventNegativeScrollOffset) {\n      scrollOffsetY = Math.max(0, scrollOffsetY);\n    }\n\n    this.scrollResponderScrollTo({\n      x: 0,\n      y: scrollOffsetY,\n      animated: true\n    });\n    this.additionalOffset = 0;\n    this.preventNegativeScrollOffset = false;\n  },\n  scrollResponderTextInputFocusError: function scrollResponderTextInputFocusError(msg) {\n    console.error('Error measuring text field: ', msg);\n  },\n  UNSAFE_componentWillMount: function UNSAFE_componentWillMount() {\n    var _ref2 = this.props,\n        keyboardShouldPersistTaps = _ref2.keyboardShouldPersistTaps;\n\n    if (typeof keyboardShouldPersistTaps === 'boolean') {\n      console.warn(\"'keyboardShouldPersistTaps={\" + (keyboardShouldPersistTaps === true ? 'true' : 'false') + \"}' is deprecated. \" + (\"Use 'keyboardShouldPersistTaps=\\\"\" + (keyboardShouldPersistTaps ? 'always' : 'never') + \"\\\"' instead\"));\n    }\n\n    this.keyboardWillOpenTo = null;\n    this.additionalScrollOffset = 0;\n    this._subscriptionKeyboardWillShow = Keyboard.addListener('keyboardWillShow', this.scrollResponderKeyboardWillShow);\n    this._subscriptionKeyboardWillHide = Keyboard.addListener('keyboardWillHide', this.scrollResponderKeyboardWillHide);\n    this._subscriptionKeyboardDidShow = Keyboard.addListener('keyboardDidShow', this.scrollResponderKeyboardDidShow);\n    this._subscriptionKeyboardDidHide = Keyboard.addListener('keyboardDidHide', this.scrollResponderKeyboardDidHide);\n  },\n  componentWillUnmount: function componentWillUnmount() {\n    if (this._subscriptionKeyboardWillShow != null) {\n      this._subscriptionKeyboardWillShow.remove();\n    }\n\n    if (this._subscriptionKeyboardWillHide != null) {\n      this._subscriptionKeyboardWillHide.remove();\n    }\n\n    if (this._subscriptionKeyboardDidShow != null) {\n      this._subscriptionKeyboardDidShow.remove();\n    }\n\n    if (this._subscriptionKeyboardDidHide != null) {\n      this._subscriptionKeyboardDidHide.remove();\n    }\n  },\n  scrollResponderKeyboardWillShow: function scrollResponderKeyboardWillShow(e) {\n    this.keyboardWillOpenTo = e;\n    this.props.onKeyboardWillShow && this.props.onKeyboardWillShow(e);\n  },\n  scrollResponderKeyboardWillHide: function scrollResponderKeyboardWillHide(e) {\n    this.keyboardWillOpenTo = null;\n    this.props.onKeyboardWillHide && this.props.onKeyboardWillHide(e);\n  },\n  scrollResponderKeyboardDidShow: function scrollResponderKeyboardDidShow(e) {\n    if (e) {\n      this.keyboardWillOpenTo = e;\n    }\n\n    this.props.onKeyboardDidShow && this.props.onKeyboardDidShow(e);\n  },\n  scrollResponderKeyboardDidHide: function scrollResponderKeyboardDidHide(e) {\n    this.keyboardWillOpenTo = null;\n    this.props.onKeyboardDidHide && this.props.onKeyboardDidHide(e);\n  }\n};\nvar ScrollResponder = {\n  Mixin: ScrollResponderMixin\n};\nmodule.exports = ScrollResponder;","map":{"version":3,"sources":["C:/Users/nicol/Documents/Repos/HackDavis/PantryPickupProject/node_modules/react-native/Libraries/Components/ScrollResponder.js"],"names":["Dimensions","require","FrameRateLogger","Keyboard","Platform","React","ReactNative","TextInputState","UIManager","invariant","Commands","IS_ANIMATING_TOUCH_START_THRESHOLD_MS","ScrollResponderMixin","_subscriptionKeyboardWillShow","_subscriptionKeyboardWillHide","_subscriptionKeyboardDidShow","_subscriptionKeyboardDidHide","scrollResponderMixinGetInitialState","isTouching","lastMomentumScrollBeginTime","lastMomentumScrollEndTime","observedScrollSinceBecomingResponder","becameResponderWhileAnimating","scrollResponderHandleScrollShouldSetResponder","props","disableScrollViewPanResponder","state","scrollResponderHandleStartShouldSetResponder","e","currentlyFocusedInput","keyboardShouldPersistTaps","scrollResponderKeyboardIsDismissible","target","scrollResponderHandleStartShouldSetResponderCapture","scrollResponderIsAnimating","keyboardNeverPersistTaps","__DEV__","console","error","isTextInput","hasFocusedTextInput","softKeyboardMayBeOpen","keyboardWillOpenTo","OS","scrollResponderHandleResponderReject","scrollResponderHandleTerminationRequest","scrollResponderHandleTouchEnd","nativeEvent","touches","length","onTouchEnd","scrollResponderHandleTouchCancel","onTouchCancel","scrollResponderHandleResponderRelease","onResponderRelease","currentlyFocusedTextInput","onScrollResponderKeyboardDismissed","blurTextInput","scrollResponderHandleScroll","onScroll","scrollResponderHandleResponderGrant","onResponderGrant","scrollResponderHandleScrollBeginDrag","beginScroll","onScrollBeginDrag","scrollResponderHandleScrollEndDrag","velocity","x","y","endScroll","onScrollEndDrag","scrollResponderHandleMomentumScrollBegin","global","performance","now","onMomentumScrollBegin","scrollResponderHandleMomentumScrollEnd","onMomentumScrollEnd","scrollResponderHandleTouchStart","onTouchStart","scrollResponderHandleTouchMove","onTouchMove","timeSinceLastMomentumScrollEnd","isAnimating","scrollResponderGetScrollableNode","getScrollableNode","findNodeHandle","scrollResponderScrollTo","animated","warn","that","getNativeScrollRef","nativeScrollRef","scrollTo","scrollResponderScrollToEnd","options","scrollToEnd","scrollResponderZoomTo","rect","zoomToRect","scrollResponderFlashScrollIndicators","flashScrollIndicators","scrollResponderScrollNativeHandleToKeyboard","nodeHandle","additionalOffset","preventNegativeScrollOffset","additionalScrollOffset","measureLayout","getInnerViewNode","scrollResponderTextInputFocusError","scrollResponderInputMeasureAndScrollToKeyboard","innerRef","getInnerViewRef","left","top","width","height","keyboardScreenY","get","endCoordinates","screenY","scrollOffsetY","Math","max","msg","UNSAFE_componentWillMount","addListener","scrollResponderKeyboardWillShow","scrollResponderKeyboardWillHide","scrollResponderKeyboardDidShow","scrollResponderKeyboardDidHide","componentWillUnmount","remove","onKeyboardWillShow","onKeyboardWillHide","onKeyboardDidShow","onKeyboardDidHide","ScrollResponder","Mixin","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format\n * @flow\n */\n\n'use strict';\n\nconst Dimensions = require('../Utilities/Dimensions');\nconst FrameRateLogger = require('../Interaction/FrameRateLogger');\nconst Keyboard = require('./Keyboard/Keyboard');\nconst Platform = require('../Utilities/Platform');\nconst React = require('react');\nconst ReactNative = require('../Renderer/shims/ReactNative');\nconst TextInputState = require('./TextInput/TextInputState');\nconst UIManager = require('../ReactNative/UIManager');\n\nconst invariant = require('invariant');\n\nimport type {HostComponent} from '../Renderer/shims/ReactNativeTypes';\nimport type {PressEvent, ScrollEvent} from '../Types/CoreEventTypes';\nimport {type EventSubscription} from '../vendor/emitter/EventEmitter';\nimport type {KeyboardEvent} from './Keyboard/Keyboard';\nimport typeof ScrollView from './ScrollView/ScrollView';\nimport type {Props as ScrollViewProps} from './ScrollView/ScrollView';\nimport Commands from './ScrollView/ScrollViewCommands';\n\n/**\n * Mixin that can be integrated in order to handle scrolling that plays well\n * with `ResponderEventPlugin`. Integrate with your platform specific scroll\n * views, or even your custom built (every-frame animating) scroll views so that\n * all of these systems play well with the `ResponderEventPlugin`.\n *\n * iOS scroll event timing nuances:\n * ===============================\n *\n *\n * Scrolling without bouncing, if you touch down:\n * -------------------------------\n *\n * 1. `onMomentumScrollBegin` (when animation begins after letting up)\n *    ... physical touch starts ...\n * 2. `onTouchStartCapture`   (when you press down to stop the scroll)\n * 3. `onTouchStart`          (same, but bubble phase)\n * 4. `onResponderRelease`    (when lifting up - you could pause forever before * lifting)\n * 5. `onMomentumScrollEnd`\n *\n *\n * Scrolling with bouncing, if you touch down:\n * -------------------------------\n *\n * 1. `onMomentumScrollBegin` (when animation begins after letting up)\n *    ... bounce begins ...\n *    ... some time elapses ...\n *    ... physical touch during bounce ...\n * 2. `onMomentumScrollEnd`   (Makes no sense why this occurs first during bounce)\n * 3. `onTouchStartCapture`   (immediately after `onMomentumScrollEnd`)\n * 4. `onTouchStart`          (same, but bubble phase)\n * 5. `onTouchEnd`            (You could hold the touch start for a long time)\n * 6. `onMomentumScrollBegin` (When releasing the view starts bouncing back)\n *\n * So when we receive an `onTouchStart`, how can we tell if we are touching\n * *during* an animation (which then causes the animation to stop)? The only way\n * to tell is if the `touchStart` occurred immediately after the\n * `onMomentumScrollEnd`.\n *\n * This is abstracted out for you, so you can just call this.scrollResponderIsAnimating() if\n * necessary\n *\n * `ScrollResponder` also includes logic for blurring a currently focused input\n * if one is focused while scrolling. The `ScrollResponder` is a natural place\n * to put this logic since it can support not dismissing the keyboard while\n * scrolling, unless a recognized \"tap\"-like gesture has occurred.\n *\n * The public lifecycle API includes events for keyboard interaction, responder\n * interaction, and scrolling (among others). The keyboard callbacks\n * `onKeyboardWill/Did/*` are *global* events, but are invoked on scroll\n * responder's props so that you can guarantee that the scroll responder's\n * internal state has been updated accordingly (and deterministically) by\n * the time the props callbacks are invoke. Otherwise, you would always wonder\n * if the scroll responder is currently in a state where it recognizes new\n * keyboard positions etc. If coordinating scrolling with keyboard movement,\n * *always* use these hooks instead of listening to your own global keyboard\n * events.\n *\n * Public keyboard lifecycle API: (props callbacks)\n *\n * Standard Keyboard Appearance Sequence:\n *\n *   this.props.onKeyboardWillShow\n *   this.props.onKeyboardDidShow\n *\n * `onScrollResponderKeyboardDismissed` will be invoked if an appropriate\n * tap inside the scroll responder's scrollable region was responsible\n * for the dismissal of the keyboard. There are other reasons why the\n * keyboard could be dismissed.\n *\n *   this.props.onScrollResponderKeyboardDismissed\n *\n * Standard Keyboard Hide Sequence:\n *\n *   this.props.onKeyboardWillHide\n *   this.props.onKeyboardDidHide\n */\n\nconst IS_ANIMATING_TOUCH_START_THRESHOLD_MS = 16;\n\nexport type State = {|\n  isTouching: boolean,\n  lastMomentumScrollBeginTime: number,\n  lastMomentumScrollEndTime: number,\n  observedScrollSinceBecomingResponder: boolean,\n  becameResponderWhileAnimating: boolean,\n|};\n\nconst ScrollResponderMixin = {\n  _subscriptionKeyboardWillShow: (null: ?EventSubscription),\n  _subscriptionKeyboardWillHide: (null: ?EventSubscription),\n  _subscriptionKeyboardDidShow: (null: ?EventSubscription),\n  _subscriptionKeyboardDidHide: (null: ?EventSubscription),\n  scrollResponderMixinGetInitialState: function(): State {\n    return {\n      isTouching: false,\n      lastMomentumScrollBeginTime: 0,\n      lastMomentumScrollEndTime: 0,\n\n      // Reset to false every time becomes responder. This is used to:\n      // - Determine if the scroll view has been scrolled and therefore should\n      // refuse to give up its responder lock.\n      // - Determine if releasing should dismiss the keyboard when we are in\n      // tap-to-dismiss mode (this.props.keyboardShouldPersistTaps !== 'always').\n      observedScrollSinceBecomingResponder: false,\n      becameResponderWhileAnimating: false,\n    };\n  },\n\n  /**\n   * Invoke this from an `onScroll` event.\n   */\n  scrollResponderHandleScrollShouldSetResponder: function(): boolean {\n    // Allow any event touch pass through if the default pan responder is disabled\n    if (this.props.disableScrollViewPanResponder === true) {\n      return false;\n    }\n    return this.state.isTouching;\n  },\n\n  /**\n   * Merely touch starting is not sufficient for a scroll view to become the\n   * responder. Being the \"responder\" means that the very next touch move/end\n   * event will result in an action/movement.\n   *\n   * Invoke this from an `onStartShouldSetResponder` event.\n   *\n   * `onStartShouldSetResponder` is used when the next move/end will trigger\n   * some UI movement/action, but when you want to yield priority to views\n   * nested inside of the view.\n   *\n   * There may be some cases where scroll views actually should return `true`\n   * from `onStartShouldSetResponder`: Any time we are detecting a standard tap\n   * that gives priority to nested views.\n   *\n   * - If a single tap on the scroll view triggers an action such as\n   *   recentering a map style view yet wants to give priority to interaction\n   *   views inside (such as dropped pins or labels), then we would return true\n   *   from this method when there is a single touch.\n   *\n   * - Similar to the previous case, if a two finger \"tap\" should trigger a\n   *   zoom, we would check the `touches` count, and if `>= 2`, we would return\n   *   true.\n   *\n   */\n  scrollResponderHandleStartShouldSetResponder: function(\n    e: PressEvent,\n  ): boolean {\n    // Allow any event touch pass through if the default pan responder is disabled\n    if (this.props.disableScrollViewPanResponder === true) {\n      return false;\n    }\n\n    const currentlyFocusedInput = TextInputState.currentlyFocusedInput();\n\n    if (\n      this.props.keyboardShouldPersistTaps === 'handled' &&\n      this.scrollResponderKeyboardIsDismissible() &&\n      e.target !== currentlyFocusedInput\n    ) {\n      return true;\n    }\n    return false;\n  },\n\n  /**\n   * There are times when the scroll view wants to become the responder\n   * (meaning respond to the next immediate `touchStart/touchEnd`), in a way\n   * that *doesn't* give priority to nested views (hence the capture phase):\n   *\n   * - Currently animating.\n   * - Tapping anywhere that is not a text input, while the keyboard is\n   *   up (which should dismiss the keyboard).\n   *\n   * Invoke this from an `onStartShouldSetResponderCapture` event.\n   */\n  scrollResponderHandleStartShouldSetResponderCapture: function(\n    e: PressEvent,\n  ): boolean {\n    // The scroll view should receive taps instead of its descendants if:\n    // * it is already animating/decelerating\n    if (this.scrollResponderIsAnimating()) {\n      return true;\n    }\n\n    // Allow any event touch pass through if the default pan responder is disabled\n    if (this.props.disableScrollViewPanResponder === true) {\n      return false;\n    }\n\n    // * the keyboard is up, keyboardShouldPersistTaps is 'never' (the default),\n    // and a new touch starts with a non-textinput target (in which case the\n    // first tap should be sent to the scroll view and dismiss the keyboard,\n    // then the second tap goes to the actual interior view)\n    const {keyboardShouldPersistTaps} = this.props;\n    const keyboardNeverPersistTaps =\n      !keyboardShouldPersistTaps || keyboardShouldPersistTaps === 'never';\n\n    if (typeof e.target === 'number') {\n      if (__DEV__) {\n        console.error(\n          'Did not expect event target to be a number. Should have been a native component',\n        );\n      }\n\n      return false;\n    }\n\n    if (\n      keyboardNeverPersistTaps &&\n      this.scrollResponderKeyboardIsDismissible() &&\n      e.target != null &&\n      !TextInputState.isTextInput(e.target)\n    ) {\n      return true;\n    }\n\n    return false;\n  },\n\n  /**\n   * Do we consider there to be a dismissible soft-keyboard open?\n   */\n  scrollResponderKeyboardIsDismissible: function(): boolean {\n    const currentlyFocusedInput = TextInputState.currentlyFocusedInput();\n\n    // We cannot dismiss the keyboard without an input to blur, even if a soft\n    // keyboard is open (e.g. when keyboard is open due to a native component\n    // not participating in TextInputState). It's also possible that the\n    // currently focused input isn't a TextInput (such as by calling ref.focus\n    // on a non-TextInput).\n    const hasFocusedTextInput =\n      currentlyFocusedInput != null &&\n      TextInputState.isTextInput(currentlyFocusedInput);\n\n    // Even if an input is focused, we may not have a keyboard to dismiss. E.g\n    // when using a physical keyboard. Ensure we have an event for an opened\n    // keyboard, except on Android where setting windowSoftInputMode to\n    // adjustNone leads to missing keyboard events.\n    const softKeyboardMayBeOpen =\n      this.keyboardWillOpenTo != null || Platform.OS === 'android';\n\n    return hasFocusedTextInput && softKeyboardMayBeOpen;\n  },\n\n  /**\n   * Invoke this from an `onResponderReject` event.\n   *\n   * Some other element is not yielding its role as responder. Normally, we'd\n   * just disable the `UIScrollView`, but a touch has already began on it, the\n   * `UIScrollView` will not accept being disabled after that. The easiest\n   * solution for now is to accept the limitation of disallowing this\n   * altogether. To improve this, find a way to disable the `UIScrollView` after\n   * a touch has already started.\n   */\n  scrollResponderHandleResponderReject: function() {},\n\n  /**\n   * We will allow the scroll view to give up its lock iff it acquired the lock\n   * during an animation. This is a very useful default that happens to satisfy\n   * many common user experiences.\n   *\n   * - Stop a scroll on the left edge, then turn that into an outer view's\n   *   backswipe.\n   * - Stop a scroll mid-bounce at the top, continue pulling to have the outer\n   *   view dismiss.\n   * - However, without catching the scroll view mid-bounce (while it is\n   *   motionless), if you drag far enough for the scroll view to become\n   *   responder (and therefore drag the scroll view a bit), any backswipe\n   *   navigation of a swipe gesture higher in the view hierarchy, should be\n   *   rejected.\n   */\n  scrollResponderHandleTerminationRequest: function(): boolean {\n    return !this.state.observedScrollSinceBecomingResponder;\n  },\n\n  /**\n   * Invoke this from an `onTouchEnd` event.\n   *\n   * @param {PressEvent} e Event.\n   */\n  scrollResponderHandleTouchEnd: function(e: PressEvent) {\n    const nativeEvent = e.nativeEvent;\n    this.state.isTouching = nativeEvent.touches.length !== 0;\n    this.props.onTouchEnd && this.props.onTouchEnd(e);\n  },\n\n  /**\n   * Invoke this from an `onTouchCancel` event.\n   *\n   * @param {PressEvent} e Event.\n   */\n  scrollResponderHandleTouchCancel: function(e: PressEvent) {\n    this.state.isTouching = false;\n    this.props.onTouchCancel && this.props.onTouchCancel(e);\n  },\n\n  /**\n   * Invoke this from an `onResponderRelease` event.\n   */\n  scrollResponderHandleResponderRelease: function(e: PressEvent) {\n    this.props.onResponderRelease && this.props.onResponderRelease(e);\n\n    if (typeof e.target === 'number') {\n      if (__DEV__) {\n        console.error(\n          'Did not expect event target to be a number. Should have been a native component',\n        );\n      }\n\n      return;\n    }\n\n    // By default scroll views will unfocus a textField\n    // if another touch occurs outside of it\n    const currentlyFocusedTextInput = TextInputState.currentlyFocusedInput();\n    if (\n      this.props.keyboardShouldPersistTaps !== true &&\n      this.props.keyboardShouldPersistTaps !== 'always' &&\n      this.scrollResponderKeyboardIsDismissible() &&\n      e.target !== currentlyFocusedTextInput &&\n      !this.state.observedScrollSinceBecomingResponder &&\n      !this.state.becameResponderWhileAnimating\n    ) {\n      this.props.onScrollResponderKeyboardDismissed &&\n        this.props.onScrollResponderKeyboardDismissed(e);\n      TextInputState.blurTextInput(currentlyFocusedTextInput);\n    }\n  },\n\n  scrollResponderHandleScroll: function(e: ScrollEvent) {\n    (this: any).state.observedScrollSinceBecomingResponder = true;\n    (this: any).props.onScroll && (this: any).props.onScroll(e);\n  },\n\n  /**\n   * Invoke this from an `onResponderGrant` event.\n   */\n  scrollResponderHandleResponderGrant: function(e: ScrollEvent) {\n    this.state.observedScrollSinceBecomingResponder = false;\n    this.props.onResponderGrant && this.props.onResponderGrant(e);\n    this.state.becameResponderWhileAnimating = this.scrollResponderIsAnimating();\n  },\n\n  /**\n   * Unfortunately, `onScrollBeginDrag` also fires when *stopping* the scroll\n   * animation, and there's not an easy way to distinguish a drag vs. stopping\n   * momentum.\n   *\n   * Invoke this from an `onScrollBeginDrag` event.\n   */\n  scrollResponderHandleScrollBeginDrag: function(e: ScrollEvent) {\n    FrameRateLogger.beginScroll(); // TODO: track all scrolls after implementing onScrollEndAnimation\n    this.props.onScrollBeginDrag && this.props.onScrollBeginDrag(e);\n  },\n\n  /**\n   * Invoke this from an `onScrollEndDrag` event.\n   */\n  scrollResponderHandleScrollEndDrag: function(e: ScrollEvent) {\n    const {velocity} = e.nativeEvent;\n    // - If we are animating, then this is a \"drag\" that is stopping the scrollview and momentum end\n    //   will fire.\n    // - If velocity is non-zero, then the interaction will stop when momentum scroll ends or\n    //   another drag starts and ends.\n    // - If we don't get velocity, better to stop the interaction twice than not stop it.\n    if (\n      !this.scrollResponderIsAnimating() &&\n      (!velocity || (velocity.x === 0 && velocity.y === 0))\n    ) {\n      FrameRateLogger.endScroll();\n    }\n    this.props.onScrollEndDrag && this.props.onScrollEndDrag(e);\n  },\n\n  /**\n   * Invoke this from an `onMomentumScrollBegin` event.\n   */\n  scrollResponderHandleMomentumScrollBegin: function(e: ScrollEvent) {\n    this.state.lastMomentumScrollBeginTime = global.performance.now();\n    this.props.onMomentumScrollBegin && this.props.onMomentumScrollBegin(e);\n  },\n\n  /**\n   * Invoke this from an `onMomentumScrollEnd` event.\n   */\n  scrollResponderHandleMomentumScrollEnd: function(e: ScrollEvent) {\n    FrameRateLogger.endScroll();\n    this.state.lastMomentumScrollEndTime = global.performance.now();\n    this.props.onMomentumScrollEnd && this.props.onMomentumScrollEnd(e);\n  },\n\n  /**\n   * Invoke this from an `onTouchStart` event.\n   *\n   * Since we know that the `SimpleEventPlugin` occurs later in the plugin\n   * order, after `ResponderEventPlugin`, we can detect that we were *not*\n   * permitted to be the responder (presumably because a contained view became\n   * responder). The `onResponderReject` won't fire in that case - it only\n   * fires when a *current* responder rejects our request.\n   *\n   * @param {PressEvent} e Touch Start event.\n   */\n  scrollResponderHandleTouchStart: function(e: PressEvent) {\n    this.state.isTouching = true;\n    this.props.onTouchStart && this.props.onTouchStart(e);\n  },\n\n  /**\n   * Invoke this from an `onTouchMove` event.\n   *\n   * Since we know that the `SimpleEventPlugin` occurs later in the plugin\n   * order, after `ResponderEventPlugin`, we can detect that we were *not*\n   * permitted to be the responder (presumably because a contained view became\n   * responder). The `onResponderReject` won't fire in that case - it only\n   * fires when a *current* responder rejects our request.\n   *\n   * @param {PressEvent} e Touch Start event.\n   */\n  scrollResponderHandleTouchMove: function(e: PressEvent) {\n    this.props.onTouchMove && this.props.onTouchMove(e);\n  },\n\n  /**\n   * A helper function for this class that lets us quickly determine if the\n   * view is currently animating. This is particularly useful to know when\n   * a touch has just started or ended.\n   */\n  scrollResponderIsAnimating: function(): boolean {\n    const now = global.performance.now();\n    const timeSinceLastMomentumScrollEnd =\n      now - this.state.lastMomentumScrollEndTime;\n    const isAnimating =\n      timeSinceLastMomentumScrollEnd < IS_ANIMATING_TOUCH_START_THRESHOLD_MS ||\n      this.state.lastMomentumScrollEndTime <\n        this.state.lastMomentumScrollBeginTime;\n    return isAnimating;\n  },\n\n  /**\n   * Returns the node that represents native view that can be scrolled.\n   * Components can pass what node to use by defining a `getScrollableNode`\n   * function otherwise `this` is used.\n   */\n  scrollResponderGetScrollableNode: function(): ?number {\n    return this.getScrollableNode\n      ? this.getScrollableNode()\n      : ReactNative.findNodeHandle(this);\n  },\n\n  /**\n   * A helper function to scroll to a specific point in the ScrollView.\n   * This is currently used to help focus child TextViews, but can also\n   * be used to quickly scroll to any element we want to focus. Syntax:\n   *\n   * `scrollResponderScrollTo(options: {x: number = 0; y: number = 0; animated: boolean = true})`\n   *\n   * Note: The weird argument signature is due to the fact that, for historical reasons,\n   * the function also accepts separate arguments as as alternative to the options object.\n   * This is deprecated due to ambiguity (y before x), and SHOULD NOT BE USED.\n   */\n  scrollResponderScrollTo: function(\n    x?:\n      | number\n      | {\n          x?: number,\n          y?: number,\n          animated?: boolean,\n          ...\n        },\n    y?: number,\n    animated?: boolean,\n  ) {\n    if (typeof x === 'number') {\n      console.warn(\n        '`scrollResponderScrollTo(x, y, animated)` is deprecated. Use `scrollResponderScrollTo({x: 5, y: 5, animated: true})` instead.',\n      );\n    } else {\n      ({x, y, animated} = x || {});\n    }\n\n    const that: React.ElementRef<ScrollView> = (this: any);\n    invariant(\n      that.getNativeScrollRef != null,\n      'Expected scrollTo to be called on a scrollViewRef. If this exception occurs it is likely a bug in React Native',\n    );\n    const nativeScrollRef = that.getNativeScrollRef();\n    if (nativeScrollRef == null) {\n      return;\n    }\n    Commands.scrollTo(nativeScrollRef, x || 0, y || 0, animated !== false);\n  },\n\n  /**\n   * Scrolls to the end of the ScrollView, either immediately or with a smooth\n   * animation.\n   *\n   * Example:\n   *\n   * `scrollResponderScrollToEnd({animated: true})`\n   */\n  scrollResponderScrollToEnd: function(options?: {animated?: boolean, ...}) {\n    // Default to true\n    const animated = (options && options.animated) !== false;\n\n    const that: React.ElementRef<ScrollView> = (this: any);\n    invariant(\n      that.getNativeScrollRef != null,\n      'Expected scrollToEnd to be called on a scrollViewRef. If this exception occurs it is likely a bug in React Native',\n    );\n    const nativeScrollRef = that.getNativeScrollRef();\n    if (nativeScrollRef == null) {\n      return;\n    }\n\n    Commands.scrollToEnd(nativeScrollRef, animated);\n  },\n\n  /**\n   * A helper function to zoom to a specific rect in the scrollview. The argument has the shape\n   * {x: number; y: number; width: number; height: number; animated: boolean = true}\n   *\n   * @platform ios\n   */\n  scrollResponderZoomTo: function(\n    rect: {|\n      x: number,\n      y: number,\n      width: number,\n      height: number,\n      animated?: boolean,\n    |},\n    animated?: boolean, // deprecated, put this inside the rect argument instead\n  ) {\n    invariant(Platform.OS === 'ios', 'zoomToRect is not implemented');\n    if ('animated' in rect) {\n      animated = rect.animated;\n      delete rect.animated;\n    } else if (typeof animated !== 'undefined') {\n      console.warn(\n        '`scrollResponderZoomTo` `animated` argument is deprecated. Use `options.animated` instead',\n      );\n    }\n\n    const that: React.ElementRef<ScrollView> = this;\n    invariant(\n      that.getNativeScrollRef != null,\n      'Expected zoomToRect to be called on a scrollViewRef. If this exception occurs it is likely a bug in React Native',\n    );\n    const nativeScrollRef = that.getNativeScrollRef();\n    if (nativeScrollRef == null) {\n      return;\n    }\n    Commands.zoomToRect(nativeScrollRef, rect, animated !== false);\n  },\n\n  /**\n   * Displays the scroll indicators momentarily.\n   */\n  scrollResponderFlashScrollIndicators: function() {\n    const that: React.ElementRef<ScrollView> = (this: any);\n    invariant(\n      that.getNativeScrollRef != null,\n      'Expected flashScrollIndicators to be called on a scrollViewRef. If this exception occurs it is likely a bug in React Native',\n    );\n    const nativeScrollRef = that.getNativeScrollRef();\n    if (nativeScrollRef == null) {\n      return;\n    }\n    Commands.flashScrollIndicators(nativeScrollRef);\n  },\n\n  /**\n   * This method should be used as the callback to onFocus in a TextInputs'\n   * parent view. Note that any module using this mixin needs to return\n   * the parent view's ref in getScrollViewRef() in order to use this method.\n   * @param {number} nodeHandle The TextInput node handle\n   * @param {number} additionalOffset The scroll view's bottom \"contentInset\".\n   *        Default is 0.\n   * @param {bool} preventNegativeScrolling Whether to allow pulling the content\n   *        down to make it meet the keyboard's top. Default is false.\n   */\n  scrollResponderScrollNativeHandleToKeyboard: function<T>(\n    nodeHandle: number | React.ElementRef<HostComponent<T>>,\n    additionalOffset?: number,\n    preventNegativeScrollOffset?: boolean,\n  ) {\n    this.additionalScrollOffset = additionalOffset || 0;\n    this.preventNegativeScrollOffset = !!preventNegativeScrollOffset;\n\n    if (typeof nodeHandle === 'number') {\n      UIManager.measureLayout(\n        nodeHandle,\n        ReactNative.findNodeHandle(this.getInnerViewNode()),\n        this.scrollResponderTextInputFocusError,\n        this.scrollResponderInputMeasureAndScrollToKeyboard,\n      );\n    } else {\n      const innerRef = this.getInnerViewRef();\n\n      if (innerRef == null) {\n        return;\n      }\n\n      nodeHandle.measureLayout(\n        innerRef,\n        this.scrollResponderInputMeasureAndScrollToKeyboard,\n        this.scrollResponderTextInputFocusError,\n      );\n    }\n  },\n\n  /**\n   * The calculations performed here assume the scroll view takes up the entire\n   * screen - even if has some content inset. We then measure the offsets of the\n   * keyboard, and compensate both for the scroll view's \"contentInset\".\n   *\n   * @param {number} left Position of input w.r.t. table view.\n   * @param {number} top Position of input w.r.t. table view.\n   * @param {number} width Width of the text input.\n   * @param {number} height Height of the text input.\n   */\n  scrollResponderInputMeasureAndScrollToKeyboard: function(\n    left: number,\n    top: number,\n    width: number,\n    height: number,\n  ) {\n    let keyboardScreenY = Dimensions.get('window').height;\n    if (this.keyboardWillOpenTo) {\n      keyboardScreenY = this.keyboardWillOpenTo.endCoordinates.screenY;\n    }\n    let scrollOffsetY =\n      top - keyboardScreenY + height + this.additionalScrollOffset;\n\n    // By default, this can scroll with negative offset, pulling the content\n    // down so that the target component's bottom meets the keyboard's top.\n    // If requested otherwise, cap the offset at 0 minimum to avoid content\n    // shifting down.\n    if (this.preventNegativeScrollOffset) {\n      scrollOffsetY = Math.max(0, scrollOffsetY);\n    }\n    this.scrollResponderScrollTo({x: 0, y: scrollOffsetY, animated: true});\n\n    this.additionalOffset = 0;\n    this.preventNegativeScrollOffset = false;\n  },\n\n  scrollResponderTextInputFocusError: function(msg: string) {\n    console.error('Error measuring text field: ', msg);\n  },\n\n  /**\n   * `componentWillMount` is the closest thing to a  standard \"constructor\" for\n   * React components.\n   *\n   * The `keyboardWillShow` is called before input focus.\n   */\n  UNSAFE_componentWillMount: function() {\n    const {keyboardShouldPersistTaps} = ((this: any).props: ScrollViewProps);\n    if (typeof keyboardShouldPersistTaps === 'boolean') {\n      console.warn(\n        `'keyboardShouldPersistTaps={${\n          keyboardShouldPersistTaps === true ? 'true' : 'false'\n        }}' is deprecated. ` +\n          `Use 'keyboardShouldPersistTaps=\"${\n            keyboardShouldPersistTaps ? 'always' : 'never'\n          }\"' instead`,\n      );\n    }\n\n    (this: any).keyboardWillOpenTo = null;\n    (this: any).additionalScrollOffset = 0;\n    this._subscriptionKeyboardWillShow = Keyboard.addListener(\n      'keyboardWillShow',\n      this.scrollResponderKeyboardWillShow,\n    );\n\n    this._subscriptionKeyboardWillHide = Keyboard.addListener(\n      'keyboardWillHide',\n      this.scrollResponderKeyboardWillHide,\n    );\n    this._subscriptionKeyboardDidShow = Keyboard.addListener(\n      'keyboardDidShow',\n      this.scrollResponderKeyboardDidShow,\n    );\n    this._subscriptionKeyboardDidHide = Keyboard.addListener(\n      'keyboardDidHide',\n      this.scrollResponderKeyboardDidHide,\n    );\n  },\n\n  componentWillUnmount: function() {\n    if (this._subscriptionKeyboardWillShow != null) {\n      this._subscriptionKeyboardWillShow.remove();\n    }\n    if (this._subscriptionKeyboardWillHide != null) {\n      this._subscriptionKeyboardWillHide.remove();\n    }\n    if (this._subscriptionKeyboardDidShow != null) {\n      this._subscriptionKeyboardDidShow.remove();\n    }\n    if (this._subscriptionKeyboardDidHide != null) {\n      this._subscriptionKeyboardDidHide.remove();\n    }\n  },\n\n  /**\n   * Warning, this may be called several times for a single keyboard opening.\n   * It's best to store the information in this method and then take any action\n   * at a later point (either in `keyboardDidShow` or other).\n   *\n   * Here's the order that events occur in:\n   * - focus\n   * - willShow {startCoordinates, endCoordinates} several times\n   * - didShow several times\n   * - blur\n   * - willHide {startCoordinates, endCoordinates} several times\n   * - didHide several times\n   *\n   * The `ScrollResponder` module callbacks for each of these events.\n   * Even though any user could have easily listened to keyboard events\n   * themselves, using these `props` callbacks ensures that ordering of events\n   * is consistent - and not dependent on the order that the keyboard events are\n   * subscribed to. This matters when telling the scroll view to scroll to where\n   * the keyboard is headed - the scroll responder better have been notified of\n   * the keyboard destination before being instructed to scroll to where the\n   * keyboard will be. Stick to the `ScrollResponder` callbacks, and everything\n   * will work.\n   *\n   * WARNING: These callbacks will fire even if a keyboard is displayed in a\n   * different navigation pane. Filter out the events to determine if they are\n   * relevant to you. (For example, only if you receive these callbacks after\n   * you had explicitly focused a node etc).\n   */\n  scrollResponderKeyboardWillShow: function(e: KeyboardEvent) {\n    this.keyboardWillOpenTo = e;\n    this.props.onKeyboardWillShow && this.props.onKeyboardWillShow(e);\n  },\n\n  scrollResponderKeyboardWillHide: function(e: KeyboardEvent) {\n    this.keyboardWillOpenTo = null;\n    this.props.onKeyboardWillHide && this.props.onKeyboardWillHide(e);\n  },\n\n  scrollResponderKeyboardDidShow: function(e: KeyboardEvent) {\n    // TODO(7693961): The event for DidShow is not available on iOS yet.\n    // Use the one from WillShow and do not assign.\n    if (e) {\n      this.keyboardWillOpenTo = e;\n    }\n    this.props.onKeyboardDidShow && this.props.onKeyboardDidShow(e);\n  },\n\n  scrollResponderKeyboardDidHide: function(e: KeyboardEvent) {\n    this.keyboardWillOpenTo = null;\n    this.props.onKeyboardDidHide && this.props.onKeyboardDidHide(e);\n  },\n};\n\nconst ScrollResponder = {\n  Mixin: ScrollResponderMixin,\n};\n\nmodule.exports = ScrollResponder;\n"]},"metadata":{},"sourceType":"module"}